import{d as z,aP as S,l as B,g as V,bk as w,Z as O,a as G,bl as N,bm as T,bn as Q,q as Z,aQ as j,aR as q,c as M,a1 as J,bo as X,aV as Y,m as K,s as k,w as A,h as aa,ba as ea,u as ta,bp as na,C as I,bq as ra,br as sa,bs as oa}from"./-oKnPsBe.js";const ia={trailing:!0};function ca(a,e=25,s={}){if(s={...ia,...s},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let i,r,l=[],n,t;const c=(_,b)=>(n=la(a,_,b),n.finally(()=>{if(n=null,s.trailing&&t&&!r){const m=c(_,t);return t=null,m}}),n),v=function(..._){return s.trailing&&(t=_),n||new Promise(b=>{const m=!r&&s.leading;clearTimeout(r),r=setTimeout(()=>{r=null;const u=s.leading?i:c(this,_);t=null;for(const h of l)h(u);l=[]},e),m?(i=c(this,_),b(i)):l.push(b)})},o=_=>{_&&(clearTimeout(_),r=null)};return v.isPending=()=>!!r,v.cancel=()=>{o(r),l=[],t=null},v.flush=()=>{if(o(r),!t||n)return;const _=t;return t=null,c(this,_)},v}async function la(a,e,s){return await a.apply(e,s)}const L=Symbol.for("nuxt:client-only"),P="<div></div>",Da=z({name:"ClientOnly",inheritAttrs:!1,props:["fallback","placeholder","placeholderTag","fallbackTag"],setup(a,{slots:e,attrs:s}){const i=S(!1);B(()=>{i.value=!0});const r=V();return r&&(r._nuxtClientOnly=!0),Z(L,!0),()=>{if(i.value){const c=e.default?.();return c&&c.length===1?[w(c[0],s)]:c}const l=e.fallback||e.placeholder;if(l)return O(l);const n=a.fallback||a.placeholder||"",t=a.fallbackTag||a.placeholderTag||"span";return G(t,s,n)}}}),R=new WeakMap;function ba(a){if(R.has(a))return R.get(a);const e={...a};return e.render?e.render=(s,i,r,l,n,t)=>{if(l.mounted$??s.mounted$){const c=a.render?.bind(s)(s,i,r,l,n,t);return c.children===null||typeof c.children=="string"?w(c):O(c)}return N(s._.vnode.el,P)}:e.template&&=`
      <template v-if="mounted$">${a.template}</template>
      <template v-else>${P}</template>
    `,e.setup=(s,i)=>{const r=T(),l=S(r.isHydrating===!1),n=V();if(r.isHydrating){const c={...n.attrs},v=ua(n);for(const o in c)delete n.attrs[o];B(()=>{Object.assign(n.attrs,c),n.vnode.dirs=v})}B(()=>{l.value=!0});const t=a.setup?.(s,i)||{};return Q(t)?Promise.resolve(t).then(c=>typeof c!="function"?(c||={},c.mounted$=l,c):(...v)=>{if(l.value||!r.isHydrating){const o=c(...v);return o.children===null||typeof o.children=="string"?w(o):O(o)}return N(n?.vnode.el,P)}):typeof t=="function"?(...c)=>{if(l.value){const v=t(...c),o=e.inheritAttrs!==!1?i.attrs:void 0;return v.children===null||typeof v.children=="string"?w(v,o):O(v,o)}return N(n?.vnode.el,P)}:Object.assign(t,{mounted$:l})},R.set(a,e),e}function ua(a){if(!a||!a.vnode.dirs)return null;const e=a.vnode.dirs;return a.vnode.dirs=null,e}function ya(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;da(a[0],a[1])&&a.unshift(e);let[s,i,r={}]=a,l=!1;const n=M(()=>J(s));if(typeof n.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=T();r.server??=!0,r.default??=_a,r.getCachedData??=x,r.lazy??=!1,r.immediate??=!0,r.deep??=X.deep,r.dedupe??="cancel",r._functionName,t._asyncData[n.value];function c(){const u={cause:"initial",dedupe:r.dedupe};return t._asyncData[n.value]?._init||(u.cachedData=r.getCachedData(n.value,t,{cause:"initial"}),t._asyncData[n.value]=$(t,n.value,i,r,u.cachedData)),()=>t._asyncData[n.value].execute(u)}const v=c(),o=t._asyncData[n.value];o._deps++;const _=r.server!==!1&&t.payload.serverRendered;{let u=function(f){const d=t._asyncData[f];d?._deps&&(d._deps--,d._deps===0&&d?._off())};const h=V();if(h&&_&&r.immediate&&!h.sp&&(h.sp=[]),h&&!h._nuxtOnBeforeMountCbs){h._nuxtOnBeforeMountCbs=[];const f=h._nuxtOnBeforeMountCbs;Y(()=>{f.forEach(d=>{d()}),f.splice(0,f.length)}),K(()=>f.splice(0,f.length))}const p=h&&(h._nuxtClientOnly||k(L,!1));_&&t.isHydrating&&(o.error.value||o.data.value!==void 0)?o.status.value=o.error.value?"error":"success":h&&(!p&&t.payload.serverRendered&&t.isHydrating||r.lazy)&&r.immediate?h._nuxtOnBeforeMountCbs.push(v):r.immediate&&o.status.value!=="success"&&v();const D=j(),y=A(n,(f,d)=>{if((f||d)&&f!==d){l=!0;const F=t._asyncData[d]?.data.value!==void 0,U=t._asyncDataPromises[d]!==void 0,H={cause:"initial",dedupe:r.dedupe};if(!t._asyncData[f]?._init){let C;d&&F?C=t._asyncData[d].data.value:(C=r.getCachedData(f,t,{cause:"initial"}),H.cachedData=C),t._asyncData[f]=$(t,f,i,r,C)}t._asyncData[f]._deps++,d&&u(d),(r.immediate||F||U)&&t._asyncData[f].execute(H),oa(()=>{l=!1})}},{flush:"sync"}),g=r.watch?A(r.watch,()=>{l||t._asyncData[n.value]?._execute({cause:"watch",dedupe:r.dedupe})}):()=>{};D&&q(()=>{y(),g(),u(n.value)})}const b={data:E(()=>t._asyncData[n.value]?.data),pending:E(()=>t._asyncData[n.value]?.pending),status:E(()=>t._asyncData[n.value]?.status),error:E(()=>t._asyncData[n.value]?.error),refresh:(...u)=>t._asyncData[n.value]?._init?t._asyncData[n.value].execute(...u):c()(),execute:(...u)=>b.refresh(...u),clear:()=>{const u=t._asyncData[n.value];if(u?._abortController)try{u._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{u._abortController=void 0}W(t,n.value)}},m=Promise.resolve(t._asyncDataPromises[n.value]).then(()=>b);return Object.assign(m,b),m}function E(a){return M({get(){return a()?.value},set(e){const s=a();s&&(s.value=e)}})}function da(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function ma(a){const e=T();if(a in e.payload.data||(e.payload.data[a]=void 0),e._asyncData[a]){const s=e._asyncData[a];s._deps++,j()&&q(()=>{s._deps--,s._deps===0&&s?._off()})}return{data:M({get(){return e._asyncData[a]?.data.value??e.payload.data[a]},set(s){e._asyncData[a]?e._asyncData[a].data.value=s:e.payload.data[a]=s}})}}async function ga(a){await new Promise(s=>ra(s));const e=a?sa(a):void 0;await T().hooks.callHookParallel("app:data:refresh",e)}function W(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=I(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function fa(a,e){const s={};for(const i of e)s[i]=a[i];return s}function $(a,e,s,i,r){a.payload._errors[e]??=void 0;const l=i.getCachedData!==x,n=s,t=i.deep?aa:S,c=r!==void 0,v=a.hook("app:data:refresh",async _=>{(!_||_.includes(e))&&await o.execute({cause:"refresh:hook"})}),o={data:t(c?r:i.default()),pending:M(()=>o.status.value==="pending"),error:ea(a.payload._errors,e),status:S("idle"),execute:(..._)=>{const[b,m=void 0]=_,u=b&&m===void 0&&typeof b=="object"?b:{};if(a._asyncDataPromises[e]&&(u.dedupe??i.dedupe)==="defer")return a._asyncDataPromises[e];{const D="cachedData"in u?u.cachedData:i.getCachedData(e,a,{cause:u.cause??"refresh:manual"});if(D!==void 0)return a.payload.data[e]=o.data.value=D,o.error.value=void 0,o.status.value="success",Promise.resolve(D)}o._abortController&&o._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),o._abortController=new AbortController,o.status.value="pending";const h=new AbortController,p=new Promise((D,y)=>{try{const g=u.timeout??i.timeout,f=va([o._abortController?.signal,u?.signal],h.signal,g);if(f.aborted){const d=f.reason;y(d instanceof Error?d:new DOMException(String(d??"Aborted"),"AbortError"));return}return f.addEventListener("abort",()=>{const d=f.reason;y(d instanceof Error?d:new DOMException(String(d??"Aborted"),"AbortError"))},{once:!0,signal:h.signal}),Promise.resolve(n(a,{signal:f})).then(D,y)}catch(g){y(g)}}).then(async D=>{let y=D;i.transform&&(y=await i.transform(D)),i.pick&&(y=fa(y,i.pick)),a.payload.data[e]=y,o.data.value=y,o.error.value=void 0,o.status.value="success"}).catch(D=>{if(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==p||o._abortController?.signal.aborted)return a._asyncDataPromises[e];if(typeof DOMException<"u"&&D instanceof DOMException&&D.name==="AbortError")return o.status.value="idle",a._asyncDataPromises[e];o.error.value=na(D),o.data.value=I(i.default()),o.status.value="error"}).finally(()=>{h.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=p,a._asyncDataPromises[e]},_execute:ca((..._)=>o.execute(..._),0,{leading:!0}),_default:i.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{v(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),l||ta(()=>{a._asyncData[e]?._init||(W(a,e),o.execute=()=>Promise.resolve())})}};return o}const _a=()=>{},x=(a,e,s)=>{if(e.isHydrating)return e.payload.data[a];if(s.cause!=="refresh:manual"&&s.cause!=="refresh:hook")return e.static.data[a]};function va(a,e,s){const i=a.filter(n=>!!n);if(typeof s=="number"&&s>=0){const n=AbortSignal.timeout?.(s);n&&i.push(n)}if(AbortSignal.any)return AbortSignal.any(i);const r=new AbortController;for(const n of i)if(n.aborted){const t=n.reason??new DOMException("Aborted","AbortError");try{r.abort(t)}catch{r.abort()}return r.signal}const l=()=>{const t=i.find(c=>c.aborted)?.reason??new DOMException("Aborted","AbortError");try{r.abort(t)}catch{r.abort()}};for(const n of i)n.addEventListener?.("abort",l,{once:!0,signal:e});return r.signal}export{Da as _,ya as a,ba as c,ga as r,ma as u};
