import{ap as w,aq as T,ar as B,f as P,a1 as V,as as q,s as x,at as U,l as W,E as j,z as M,r as A,au as N,av as I,p as G,aw as J,a as F,ax as Q,ay as X,az as Y}from"./k8T7zV5X.js";import{a as Z}from"./BXwB8wQH.js";const $={trailing:!0};function K(a,e=25,s={}){if(s={...$,...s},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let i,n,D=[],r,t;const h=(d,v)=>(r=k(a,d,v),r.finally(()=>{if(r=null,s.trailing&&t&&!n){const m=h(d,t);return t=null,m}}),r),b=function(...d){return s.trailing&&(t=d),r||new Promise(v=>{const m=!n&&s.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const c=s.leading?i:h(this,d);t=null;for(const f of D)f(c);D=[]},e),m?(i=h(this,d),v(i)):D.push(v)})},o=d=>{d&&(clearTimeout(d),n=null)};return b.isPending=()=>!!n,b.cancel=()=>{o(n),D=[],t=null},b.flush=()=>{if(o(n),!t||r)return;const d=t;return t=null,h(this,d)},b}async function k(a,e,s){return await a.apply(e,s)}function oa(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;aa(a[0],a[1])&&a.unshift(e);let[s,i,n={}]=a,D=!1;const r=P(()=>V(s));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=w();n.server??=!0,n.default??=ta,n.getCachedData??=H,n.lazy??=!1,n.immediate??=!0,n.deep??=q.deep,n.dedupe??="cancel",n._functionName,t._asyncData[r.value];function h(){const c={cause:"initial",dedupe:n.dedupe};return t._asyncData[r.value]?._init||(c.cachedData=n.getCachedData(r.value,t,{cause:"initial"}),t._asyncData[r.value]=R(t,r.value,i,n,c.cachedData)),()=>t._asyncData[r.value].execute(c)}const b=h(),o=t._asyncData[r.value];o._deps++;const d=n.server!==!1&&t.payload.serverRendered;{let c=function(u){const l=t._asyncData[u];l?._deps&&(l._deps--,l._deps===0&&l?._off())};const f=x();if(f&&d&&n.immediate&&!f.sp&&(f.sp=[]),f&&!f._nuxtOnBeforeMountCbs){f._nuxtOnBeforeMountCbs=[];const u=f._nuxtOnBeforeMountCbs;U(()=>{u.forEach(l=>{l()}),u.splice(0,u.length)}),W(()=>u.splice(0,u.length))}const C=f&&(f._nuxtClientOnly||j(Z,!1));d&&t.isHydrating&&(o.error.value||o.data.value!==void 0)?o.status.value=o.error.value?"error":"success":f&&(!C&&t.payload.serverRendered&&t.isHydrating||n.lazy)&&n.immediate?f._nuxtOnBeforeMountCbs.push(b):n.immediate&&o.status.value!=="success"&&b();const _=T(),y=M(r,(u,l)=>{if((u||l)&&u!==l){D=!0;const O=t._asyncData[l]?.data.value!==void 0,L=t._asyncDataPromises[l]!==void 0,S={cause:"initial",dedupe:n.dedupe};if(!t._asyncData[u]?._init){let p;l&&O?p=t._asyncData[l].data.value:(p=n.getCachedData(u,t,{cause:"initial"}),S.cachedData=p),t._asyncData[u]=R(t,u,i,n,p)}t._asyncData[u]._deps++,l&&c(l),(n.immediate||O||L)&&t._asyncData[u].execute(S),Y(()=>{D=!1})}},{flush:"sync"}),g=n.watch?M(n.watch,()=>{D||t._asyncData[r.value]?._execute({cause:"watch",dedupe:n.dedupe})}):()=>{};_&&B(()=>{y(),g(),c(r.value)})}const v={data:E(()=>t._asyncData[r.value]?.data),pending:E(()=>t._asyncData[r.value]?.pending),status:E(()=>t._asyncData[r.value]?.status),error:E(()=>t._asyncData[r.value]?.error),refresh:(...c)=>t._asyncData[r.value]?._init?t._asyncData[r.value].execute(...c):h()(),execute:(...c)=>v.refresh(...c),clear:()=>{const c=t._asyncData[r.value];if(c?._abortController)try{c._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{c._abortController=void 0}z(t,r.value)}},m=Promise.resolve(t._asyncDataPromises[r.value]).then(()=>v);return Object.assign(m,v),m}function E(a){return P({get(){return a()?.value},set(e){const s=a();s&&(s.value=e)}})}function aa(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function ia(a){const e=w();if(a in e.payload.data||(e.payload.data[a]=void 0),e._asyncData[a]){const s=e._asyncData[a];s._deps++,T()&&B(()=>{s._deps--,s._deps===0&&s?._off()})}return{data:P({get(){return e._asyncData[a]?.data.value??e.payload.data[a]},set(s){e._asyncData[a]?e._asyncData[a].data.value=s:e.payload.data[a]=s}})}}async function ca(a){await new Promise(s=>Q(s));const e=a?X(a):void 0;await w().hooks.callHookParallel("app:data:refresh",e)}function z(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=F(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function ea(a,e){const s={};for(const i of e)s[i]=a[i];return s}function R(a,e,s,i,n){a.payload._errors[e]??=void 0;const D=i.getCachedData!==H,r=s,t=i.deep?A:N,h=n!==void 0,b=a.hook("app:data:refresh",async d=>{(!d||d.includes(e))&&await o.execute({cause:"refresh:hook"})}),o={data:t(h?n:i.default()),pending:P(()=>o.status.value==="pending"),error:I(a.payload._errors,e),status:N("idle"),execute:(...d)=>{const[v,m=void 0]=d,c=v&&m===void 0&&typeof v=="object"?v:{};if(a._asyncDataPromises[e]&&(c.dedupe??i.dedupe)==="defer")return a._asyncDataPromises[e];{const _="cachedData"in c?c.cachedData:i.getCachedData(e,a,{cause:c.cause??"refresh:manual"});if(_!==void 0)return a.payload.data[e]=o.data.value=_,o.error.value=void 0,o.status.value="success",Promise.resolve(_)}o._abortController&&o._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),o._abortController=new AbortController,o.status.value="pending";const f=new AbortController,C=new Promise((_,y)=>{try{const g=c.timeout??i.timeout,u=na([o._abortController?.signal,c?.signal],f.signal,g);if(u.aborted){const l=u.reason;y(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"));return}return u.addEventListener("abort",()=>{const l=u.reason;y(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"))},{once:!0,signal:f.signal}),Promise.resolve(r(a,{signal:u})).then(_,y)}catch(g){y(g)}}).then(async _=>{let y=_;i.transform&&(y=await i.transform(_)),i.pick&&(y=ea(y,i.pick)),a.payload.data[e]=y,o.data.value=y,o.error.value=void 0,o.status.value="success"}).catch(_=>{if(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==C||o._abortController?.signal.aborted)return a._asyncDataPromises[e];if(typeof DOMException<"u"&&_ instanceof DOMException&&_.name==="AbortError")return o.status.value="idle",a._asyncDataPromises[e];o.error.value=J(_),o.data.value=F(i.default()),o.status.value="error"}).finally(()=>{f.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=C,a._asyncDataPromises[e]},_execute:K((...d)=>o.execute(...d),0,{leading:!0}),_default:i.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{b(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),D||G(()=>{a._asyncData[e]?._init||(z(a,e),o.execute=()=>Promise.resolve())})}};return o}const ta=()=>{},H=(a,e,s)=>{if(e.isHydrating)return e.payload.data[a];if(s.cause!=="refresh:manual"&&s.cause!=="refresh:hook")return e.static.data[a]};function na(a,e,s){const i=a.filter(r=>!!r);if(typeof s=="number"&&s>=0){const r=AbortSignal.timeout?.(s);r&&i.push(r)}if(AbortSignal.any)return AbortSignal.any(i);const n=new AbortController;for(const r of i)if(r.aborted){const t=r.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}return n.signal}const D=()=>{const t=i.find(h=>h.aborted)?.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}};for(const r of i)r.addEventListener?.("abort",D,{once:!0,signal:e});return n.signal}export{oa as a,ca as r,ia as u};
