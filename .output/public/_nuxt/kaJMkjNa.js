import{av as p,al as O,aw as S,ax as N,U as T,l as j,z as H,ay as U,az as W,j as R,a7 as q,aA as G,aB as x,A as J,D as Q,v as V,aC as X,aD as Y,q as Z,aE as K,E as k,aF as ee,g as A,aG as ae}from"./BBuQfMQW.js";const te={trailing:!0};function ne(e,a=25,o={}){if(o={...te,...o},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let i,r,f=[],n,t;const c=(v,h)=>(n=re(e,v,h),n.finally(()=>{if(n=null,o.trailing&&t&&!r){const b=c(v,t);return t=null,b}}),n),_=function(...v){return o.trailing&&(t=v),n||new Promise(h=>{const b=!r&&o.leading;clearTimeout(r),r=setTimeout(()=>{r=null;const l=o.leading?i:c(this,v);t=null;for(const D of f)D(l);f=[]},a),b?(i=c(this,v),h(i)):f.push(h)})},s=v=>{v&&(clearTimeout(v),r=null)};return _.isPending=()=>!!r,_.cancel=()=>{s(r),f=[],t=null},_.flush=()=>{if(s(r),!t||n)return;const v=t;return t=null,c(this,v)},_}async function re(e,a,o){return await e.apply(a,o)}const se=Symbol.for("nuxt:client-only"),P="<div></div>",M=new WeakMap;function fe(e){if(M.has(e))return M.get(e);const a={...e};return a.render?a.render=(o,i,r,f,n,t)=>{if(f.mounted$??o.mounted$){const c=e.render?.bind(o)(o,i,r,f,n,t);return c.children===null||typeof c.children=="string"?p(c):O(c)}return S(o._.vnode.el,P)}:a.template&&=`
      <template v-if="mounted$">${e.template}</template>
      <template v-else>${P}</template>
    `,a.setup=(o,i)=>{const r=N(),f=T(r.isHydrating===!1),n=j();if(r.isHydrating){const c={...n.attrs},_=oe(n);for(const s in c)delete n.attrs[s];H(()=>{Object.assign(n.attrs,c),n.vnode.dirs=_})}H(()=>{f.value=!0});const t=e.setup?.(o,i)||{};return U(t)?Promise.resolve(t).then(c=>typeof c!="function"?(c||={},c.mounted$=f,c):(..._)=>{if(f.value||!r.isHydrating){const s=c(..._);return s.children===null||typeof s.children=="string"?p(s):O(s)}return S(n?.vnode.el,P)}):typeof t=="function"?(...c)=>{if(f.value){const _=t(...c),s=a.inheritAttrs!==!1?i.attrs:void 0;return _.children===null||typeof _.children=="string"?p(_,s):O(_,s)}return S(n?.vnode.el,P)}:Object.assign(t,{mounted$:f})},M.set(e,a),a}function oe(e){if(!e||!e.vnode.dirs)return null;const a=e.vnode.dirs;return e.vnode.dirs=null,a}function ve(...e){const a=typeof e[e.length-1]=="string"?e.pop():void 0;ie(e[0],e[1])&&e.unshift(a);let[o,i,r={}]=e,f=!1;const n=R(()=>q(o));if(typeof n.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=N();r.server??=!0,r.default??=le,r.getCachedData??=I,r.lazy??=!1,r.immediate??=!0,r.deep??=G.deep,r.dedupe??="cancel",r._functionName,t._asyncData[n.value];function c(){const l={cause:"initial",dedupe:r.dedupe};return t._asyncData[n.value]?._init||(l.cachedData=r.getCachedData(n.value,t,{cause:"initial"}),t._asyncData[n.value]=$(t,n.value,i,r,l.cachedData)),()=>t._asyncData[n.value].execute(l)}const _=c(),s=t._asyncData[n.value];s._deps++;const v=r.server!==!1&&t.payload.serverRendered;{let l=function(d){const u=t._asyncData[d];u?._deps&&(u._deps--,u._deps===0&&u?._off())};const D=j();if(D&&v&&r.immediate&&!D.sp&&(D.sp=[]),D&&!D._nuxtOnBeforeMountCbs){D._nuxtOnBeforeMountCbs=[];const d=D._nuxtOnBeforeMountCbs;x(()=>{d.forEach(u=>{u()}),d.splice(0,d.length)}),J(()=>d.splice(0,d.length))}const C=D&&(D._nuxtClientOnly||Q(se,!1));v&&t.isHydrating&&(s.error.value||s.data.value!==void 0)?s.status.value=s.error.value?"error":"success":D&&(!C&&t.payload.serverRendered&&t.isHydrating||r.lazy)&&r.immediate?D._nuxtOnBeforeMountCbs.push(_):r.immediate&&s.status.value!=="success"&&_();const y=Y(),m=V(n,(d,u)=>{if((d||u)&&d!==u){f=!0;const B=t._asyncData[u]?.data.value!==void 0,L=t._asyncDataPromises[u]!==void 0,F={cause:"initial",dedupe:r.dedupe};if(!t._asyncData[d]?._init){let E;u&&B?E=t._asyncData[u].data.value:(E=r.getCachedData(d,t,{cause:"initial"}),F.cachedData=E),t._asyncData[d]=$(t,d,i,r,E)}t._asyncData[d]._deps++,u&&l(u),(r.immediate||B||L)&&t._asyncData[d].execute(F),ae(()=>{f=!1})}},{flush:"sync"}),g=r.watch?V(r.watch,()=>{f||t._asyncData[n.value]?._execute({cause:"watch",dedupe:r.dedupe})}):()=>{};y&&X(()=>{m(),g(),l(n.value)})}const h={data:w(()=>t._asyncData[n.value]?.data),pending:w(()=>t._asyncData[n.value]?.pending),status:w(()=>t._asyncData[n.value]?.status),error:w(()=>t._asyncData[n.value]?.error),refresh:(...l)=>t._asyncData[n.value]?._init?t._asyncData[n.value].execute(...l):c()(),execute:(...l)=>h.refresh(...l),clear:()=>{const l=t._asyncData[n.value];if(l?._abortController)try{l._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{l._abortController=void 0}z(t,n.value)}},b=Promise.resolve(t._asyncDataPromises[n.value]).then(()=>h);return Object.assign(b,h),b}function w(e){return R({get(){return e()?.value},set(a){const o=e();o&&(o.value=a)}})}function ie(e,a){return!(typeof e=="string"||typeof e=="object"&&e!==null||typeof e=="function"&&typeof a=="function")}async function _e(e){await new Promise(o=>W(o)),await N().hooks.callHookParallel("app:data:refresh",void 0)}function z(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=void 0),e._asyncData[a]&&(e._asyncData[a].data.value=A(e._asyncData[a]._default()),e._asyncData[a].error.value=void 0,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]=void 0)}function ce(e,a){const o={};for(const i of a)o[i]=e[i];return o}function $(e,a,o,i,r){e.payload._errors[a]??=void 0;const f=i.getCachedData!==I,n=o,t=i.deep?Z:T,c=r!==void 0,_=e.hook("app:data:refresh",async v=>{(!v||v.includes(a))&&await s.execute({cause:"refresh:hook"})}),s={data:t(c?r:i.default()),pending:R(()=>s.status.value==="pending"),error:K(e.payload._errors,a),status:T("idle"),execute:(...v)=>{const[h,b=void 0]=v,l=h&&b===void 0&&typeof h=="object"?h:{};if(e._asyncDataPromises[a]&&(l.dedupe??i.dedupe)==="defer")return e._asyncDataPromises[a];{const y="cachedData"in l?l.cachedData:i.getCachedData(a,e,{cause:l.cause??"refresh:manual"});if(y!==void 0)return e.payload.data[a]=s.data.value=y,s.error.value=void 0,s.status.value="success",Promise.resolve(y)}s._abortController&&s._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),s._abortController=new AbortController,s.status.value="pending";const D=new AbortController,C=new Promise((y,m)=>{try{const g=l.timeout??i.timeout,d=ue([s._abortController?.signal,l?.signal],D.signal,g);if(d.aborted){const u=d.reason;m(u instanceof Error?u:new DOMException(String(u??"Aborted"),"AbortError"));return}return d.addEventListener("abort",()=>{const u=d.reason;m(u instanceof Error?u:new DOMException(String(u??"Aborted"),"AbortError"))},{once:!0,signal:D.signal}),Promise.resolve(n(e,{signal:d})).then(y,m)}catch(g){m(g)}}).then(async y=>{let m=y;i.transform&&(m=await i.transform(y)),i.pick&&(m=ce(m,i.pick)),e.payload.data[a]=m,s.data.value=m,s.error.value=void 0,s.status.value="success"}).catch(y=>{if(e._asyncDataPromises[a]&&e._asyncDataPromises[a]!==C||s._abortController?.signal.aborted)return e._asyncDataPromises[a];if(typeof DOMException<"u"&&y instanceof DOMException&&y.name==="AbortError")return s.status.value="idle",e._asyncDataPromises[a];s.error.value=ee(y),s.data.value=A(i.default()),s.status.value="error"}).finally(()=>{D.abort(),delete e._asyncDataPromises[a]});return e._asyncDataPromises[a]=C,e._asyncDataPromises[a]},_execute:ne((...v)=>s.execute(...v),0,{leading:!0}),_default:i.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{_(),e._asyncData[a]?._init&&(e._asyncData[a]._init=!1),f||k(()=>{e._asyncData[a]?._init||(z(e,a),s.execute=()=>Promise.resolve())})}};return s}const le=()=>{},I=(e,a,o)=>{if(a.isHydrating)return a.payload.data[e];if(o.cause!=="refresh:manual"&&o.cause!=="refresh:hook")return a.static.data[e]};function ue(e,a,o){const i=e.filter(n=>!!n);if(typeof o=="number"&&o>=0){const n=AbortSignal.timeout?.(o);n&&i.push(n)}if(AbortSignal.any)return AbortSignal.any(i);const r=new AbortController;for(const n of i)if(n.aborted){const t=n.reason??new DOMException("Aborted","AbortError");try{r.abort(t)}catch{r.abort()}return r.signal}const f=()=>{const t=i.find(c=>c.aborted)?.reason??new DOMException("Aborted","AbortError");try{r.abort(t)}catch{r.abort()}};for(const n of i)n.addEventListener?.("abort",f,{once:!0,signal:a});return r.signal}export{fe as c,_e as r,ve as u};
